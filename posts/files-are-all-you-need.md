---
title: "From “Everything is a File” to “Files Are All You Need”: What a 50-Year-Old Unix Philosophy Teaches…"
date: "2026-01-24"
coverImage: "https://cdn-images-1.medium.com/max/1024/1*4I-aFJKW6tUZjNv0w6AlFg.png"
canonical: "https://medium.com/@prdeepak.babu/from-everything-is-a-file-to-files-are-all-you-need-what-a-50-year-old-unix-philosophy-teaches-b51658fcfadb"
mediumId: "b51658fcfadb"
source: "medium"
---

<section name="11f1" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="f221" id="f221" class="graf graf--p graf-after--h3"><em class="markup--em markup--p-em">How a design principle from 1970s operating systems is quietly shaping the future of autonomous AI</em></p><h3 name="dbbc" id="dbbc" class="graf graf--h3 graf-after--p">Introduction</h3><p name="d9d9" id="d9d9" class="graf graf--p graf-after--h3">In 1971, Ken Thompson and Dennis Ritchie faced a problem that sounds oddly familiar today. They were building Unix at Bell Labs, and the computing systems of the era were a mess. You needed one set of commands for disk access, another for terminal control, yet another for inter-process communication. Every new capability meant learning a new API. The proliferation of special-purpose interfaces made systems difficult to learn, compose, and maintain.</p><p name="d332" id="d332" class="graf graf--p graf-after--p">Their solution was elegantly simple: make everything look like a file. A hard drive? It’s a file. A terminal? Also a file. Network connections, processes, devices — all files. Open, read, write, close. Four operations to rule them all.</p><p name="b5c8" id="b5c8" class="graf graf--p graf-after--figure">This wasn’t the only possible design. But it proved remarkably durable. The abstraction survived decades of hardware evolution and remains foundational in Linux, macOS, and countless embedded systems today. Fifty years later, builders of autonomous AI agents are rediscovering this same insight. And understanding why might change how you think about building AI systems.</p><p name="5524" id="5524" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">The Problem That Keeps Coming Back</strong></p><p name="fa6a" id="fa6a" class="graf graf--p graf-after--p">Here’s the thing about computing: the same problems keep showing up at different scales.</p><p name="c53a" id="c53a" class="graf graf--p graf-after--p">In the 1970s, the problem was hardware diversity. Different vendors, different protocols, different ways of talking to machines. The file abstraction solved it by providing a universal handle. Whether a programmer wanted to read data from a disk, receive input from a keyboard, or communicate with another process, they used the same set of system calls. The underlying complexity didn’t disappear, but it was encapsulated behind a consistent interface.</p><p name="fd32" id="fd32" class="graf graf--p graf-after--p">In the 2010s, the problem resurfaced as operational complexity. DevOps teams were drowning in manual configurations, deployment scripts, and infrastructure settings. Click here to provision a server, run this script to deploy, update that console to change a policy. The solution became known as “Infrastructure as Code” — treating servers, networks, and databases not as things you click into existence, but as text files you commit to version control. Infrastructure definitions moved from console clicks to Terraform. Deployment workflows moved from runbooks to YAML. Security policies moved from guidelines to machine-evaluable rules.</p><p name="fff1" id="fff1" class="graf graf--p graf-after--p">Now, in the 2020s, AI agents face the same fundamental challenge. A capable autonomous agent might need to query databases, call REST APIs, manage cloud infrastructure, store and retrieve memories, search through documents, and interact with humans. Each capability comes with its own protocol, authentication scheme, and data format. Without some unifying principle, the complexity becomes unmanageable.</p><p name="b7fa" id="b7fa" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">The Pattern Emerges Again</strong></p><p name="d8d8" id="d8d8" class="graf graf--p graf-after--p">Jerry Liu, creator of LlamaIndex, recently documented [<a href="https://www.llamaindex.ai/blog/files-are-all-you-need" data-href="https://www.llamaindex.ai/blog/files-are-all-you-need" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">three patterns</a>] emerging in coding agents that echo Unix’s original insight.</p><p name="5db7" id="5db7" class="graf graf--p graf-after--p">The first is conversation history as files. When context windows fill up and compaction occurs, agents lose their working memory. But if you store conversations to searchable files, the agent can read back what it previously discussed rather than starting fresh each time. The filesystem becomes a form of long-term memory.</p><p name="be1b" id="be1b" class="graf graf--p graf-after--p">The second pattern is context retrieval via file traversal. Rather than relying solely on vector similarity search, agents are learning to traverse file systems the way a human developer might — scanning directories, drilling down into relevant files, reading specific sections. This interleaving of search and reading mimics how we actually explore codebases.</p><p name="f6ad" id="f6ad" class="graf graf--p graf-after--p">The third pattern is perhaps the most interesting: skills as documentation files. Instead of defining programmatic tools with custom code for each capability, developers are dropping markdown files that describe how to accomplish tasks. The agent reads and follows them like a human would read documentation. Anthropic calls these “skills” — essentially text files that teach the agent new capabilities without any code changes.</p><p name="4560" id="4560" class="graf graf--p graf-after--p">As Liu puts it: “The agent really only has access to a filesystem and ~5–10 tools: CLI over filesystem, code interpreter, web fetch — and this is just as general, if not more general, than agent with 100+ MCP tools.”</p><p name="7906" id="7906" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Why Files Keep Working</strong></p><p name="5939" id="5939" class="graf graf--p graf-after--p">The file abstraction keeps proving useful because it solves a specific problem elegantly: how to make heterogeneous resources composable.</p><p name="6fc6" id="6fc6" class="graf graf--p graf-after--p">When everything speaks the same language — bytes in, bytes out — you can combine small, focused tools into complex workflows without any of them knowing about the others. The Unix pipe works because all programs speak the same language of byte streams. `ps aux | grep python | less` chains three programs together, each doing one thing well, none of them aware of the others’ existence.</p><p name="a37c" id="a37c" class="graf graf--p graf-after--p">For AI agents, this translates naturally. Memory becomes files that can be read, written, and searched. Tools become code that can be generated and executed. Skills become documentation that can be parsed and followed. Context becomes a namespace that can be traversed. The agent doesn’t need a hundred specialized integrations — it needs to understand files and code.</p><p name="4432" id="4432" class="graf graf--p graf-after--p">Recent academic work has begun to formalize this approach. The AIGNE framework proposes an “Agentic File System” where heterogeneous resources — memory stores, tools, external APIs — are mounted into a unified namespace. History, memory, and scratchpads become file-like resources with metadata and access controls. The same operations that work on one resource work on all of them.</p><p name="a59a" id="a59a" class="graf graf--p graf-after--p">Anthropic’s engineering team has documented how their multi-agent research system relies heavily on file-like memory abstractions. When a lead agent spawns specialized subagents, they communicate through shared memory that behaves like files — agents save plans, retrieve context, and pass findings through read/write operations on a shared namespace. The architecture treats memory as infrastructure, not magic.</p><p name="1e79" id="1e79" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Code as the Action Language</strong></p><p name="1c69" id="1c69" class="graf graf--p graf-after--p">Files provide structure for context; code provides a language for action. These two elements work together.</p><p name="0ca6" id="0ca6" class="graf graf--p graf-after--p">A SQL query is unambiguous in a way that “find the relevant customer records” is not. A Python script can be tested, debugged, and sandboxed. A Terraform plan can be previewed before execution. Code makes it possible to verify, constrain, and audit what an agent does.</p><p name="eb0b" id="eb0b" class="graf graf--p graf-after--p">The practical implication is that agents built around code generation often require fewer custom tools. Rather than defining a specific tool for querying a database, the agent writes SQL. Rather than defining a tool for API calls, the agent writes a Python request or curl command. The agent becomes a “code transformer” — receiving goals in natural language and producing code that accomplishes them.</p><p name="de68" id="de68" class="graf graf--p graf-after--p">This parallels the Unix observation again. Unix reduced N device-specific APIs to a handful of system calls; coding agents reduce N service-specific tool definitions to code generation plus execution. The surface area shrinks, and what remains is more uniform.</p><p name="f2df" id="f2df" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">What This Means If You’re Building Agents</strong></p><p name="4c38" id="4c38" class="graf graf--p graf-after--p">If you’re building AI agents, a few practical considerations follow from this pattern.</p><p name="26c0" id="26c0" class="graf graf--p graf-after--p">Consider designing around file-like abstractions. Whether dealing with memory, tools, or external services, exposing them through a namespace that agents can traverse with standard operations — list, read, write, search, execute — may simplify your architecture significantly. You’re trading some specialized efficiency for composability and maintainability.</p><p name="700c" id="700c" class="graf graf--p graf-after--p">Let agents generate code rather than accumulating tool integrations. Code generation allows agents to interact with APIs, databases, and services without requiring dedicated integration code for each. The tradeoff is that code execution requires sandboxing, but these are well-understood problems with established solutions.</p><p name="fbf4" id="fbf4" class="graf graf--p graf-after--p">Leverage the DevOps infrastructure you already have. Version control, CI/CD pipelines, GitOps workflows — the tools built for managing code artifacts apply equally well to agent artifacts. Your agent’s plans, memories, and outputs can live in the same systems you already know how to operate.</p><p name="f946" id="f946" class="graf graf--p graf-after--p">Maintain traceability. Every substantive agent action should produce an auditable artifact: a diff, a log entry, a commit. File-based abstractions make this natural. When things go wrong — and they will — you’ll want to know exactly what happened.</p><p name="c2c2" id="c2c2" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">The Deeper Lesson</strong></p><p name="b2a2" id="b2a2" class="graf graf--p graf-after--p">What connects Unix, DevOps, and agentic AI isn’t just files — it’s a recurring strategy for managing complexity. The pattern is this: collapse diverse interfaces into a uniform abstraction, accepting some loss of specialization in exchange for composability and tractability.</p><p name="a078" id="a078" class="graf graf--p graf-after--p">The specific abstraction changes across eras — files, code, file-like resources — but the underlying move is the same. In each case, practitioners faced a proliferation of special-purpose interfaces that made systems hard to build, understand, and maintain. In each case, introducing a common abstraction reduced the cognitive and engineering burden, enabling composition and reuse.</p><p name="c34f" id="c34f" class="graf graf--p graf-after--p">Files aren’t magic. They don’t solve every problem. Non-text formats need parsing. Large document collections need indexing beyond simple grep. Some interactions don’t map naturally to file operations. These are real limitations, not reasons to abandon the abstraction.</p><p name="a9e2" id="a9e2" class="graf graf--p graf-after--p">But as a default model — a way of thinking about resources that covers most cases — the file metaphor has proven remarkably resilient. It worked for operating systems. It worked for operations. And it appears to be working for AI agents.</p><p name="17c9" id="17c9" class="graf graf--p graf-after--p">Sometimes the best ideas aren’t new. They’re just rediscovered at the right moment.</p><p name="2fa5" id="2fa5" class="graf graf--p graf-after--p">The ideas here often come up implicitly in discussions about agent design.You may find the full paper helpful to reference if you are:</p><ul class="postList"><li name="9325" id="9325" class="graf graf--li graf-after--p">Designing agent architectures with memory, tools, and planning components</li><li name="7432" id="7432" class="graf graf--li graf-after--li">Arguing for simpler, more uniform abstractions in agent systems</li><li name="b262" id="b262" class="graf graf--li graf-after--li">Writing about code-centric or file-centric approaches to AI autonomy</li><li name="2583" id="2583" class="graf graf--li graf-after--li">Teaching systems-inspired perspectives on modern AI engineering</li></ul><p name="8722" id="8722" class="graf graf--p graf-after--li">The full paper is available here: <a href="https://arxiv.org/abs/2601.11672" data-href="https://arxiv.org/abs/2601.11672" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://arxiv.org/abs/2601.11672</a></p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="markdown" name="b42d" id="b42d" class="graf graf--pre graf-after--p graf--trailing graf--preV2"><span class="pre--content">@article{piskala2026from,<br />  title={From Everything-is-a-File to Files-Are-All-You-Need: How Unix Philosophy Informs the Design of Agentic AI Systems},<br />  author={Piskala, Deepak Babu},<br />  journal={arXiv preprint arXiv:2601.11672},<br />  year={2026}<br />}</span></pre></div></div></section><section name="feb3" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="24c5" id="24c5" class="graf graf--p graf--leading"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">You Might Like</em></strong></p><div name="905b" id="905b" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/@prdeepak.babu/abundance-jobs-and-specialists-the-missing-connection-a82cf5318f01" data-href="https://medium.com/@prdeepak.babu/abundance-jobs-and-specialists-the-missing-connection-a82cf5318f01" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/@prdeepak.babu/abundance-jobs-and-specialists-the-missing-connection-a82cf5318f01"><strong class="markup--strong markup--mixtapeEmbed-strong">Abundance, Jobs, and Specialists: The Missing Connection</strong><br><em class="markup--em markup--mixtapeEmbed-em">As AI gets faster and more capable, our assumptions about expertise and jobs are being rewritten. This essay connects…</em>medium.com</a><a href="https://medium.com/@prdeepak.babu/abundance-jobs-and-specialists-the-missing-connection-a82cf5318f01" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="15cacaa0b3200b7babd41872494f0bd3" data-thumbnail-img-id="1*5LxBaix-bDtnesfhKS0tDg.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*5LxBaix-bDtnesfhKS0tDg.png);"></a></div><div name="97ff" id="97ff" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed graf--trailing"><a href="https://medium.com/data-science-collective/lessons-learned-from-building-enterprise-ai-agents-for-millions-of-users-cfd6a1ad3f56" data-href="https://medium.com/data-science-collective/lessons-learned-from-building-enterprise-ai-agents-for-millions-of-users-cfd6a1ad3f56" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/data-science-collective/lessons-learned-from-building-enterprise-ai-agents-for-millions-of-users-cfd6a1ad3f56"><strong class="markup--strong markup--mixtapeEmbed-strong">Lessons Learned from Building Enterprise AI Agents for Millions of Users</strong><br><em class="markup--em markup--mixtapeEmbed-em">Insights, pitfalls, and architectural truths from real-world deployments</em>medium.com</a><a href="https://medium.com/data-science-collective/lessons-learned-from-building-enterprise-ai-agents-for-millions-of-users-cfd6a1ad3f56" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="daabef06ce731a9a8beed0ac62df8146" data-thumbnail-img-id="1*_eRYDPrKFV57qzVTU7SfDA.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*_eRYDPrKFV57qzVTU7SfDA.png);"></a></div></div></div></section>

<hr>

<p><em>Originally published on Medium:</em> <a href="https://medium.com/@prdeepak.babu/from-everything-is-a-file-to-files-are-all-you-need-what-a-50-year-old-unix-philosophy-teaches-b51658fcfadb">https://medium.com/@prdeepak.babu/from-everything-is-a-file-to-files-are-all-you-need-what-a-50-year-old-unix-philosophy-teaches-b51658fcfadb</a></p>
